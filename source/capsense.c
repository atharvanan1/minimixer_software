

/*****************************
 * File: capsense.c
 * Description: This file contains the capsense library
 * 				given in the touch demo
 *
 * 		This file is functional, but requires a polling implementation
 *****************************/




#include <stdint.h>
#include <stdbool.h>


#include "em_acmp.h"
#include "em_assert.h"
#include "em_chip.h"
#include "em_cmu.h"
#include "em_core.h"
#include "em_device.h"
#include "em_emu.h"
#include "em_gpio.h"
//#include "em_lesense.h"
//#include "em_pcnt.h"
#include "em_timer.h"
#include "em_prs.h"
//#include "em_vdac.h"

#include "capsense.h"
#include "events.h"
#include "native_gecko.h"


/** The current channel we are sensing. */
static volatile uint8_t currentChannel;

/** Flag for measurement completion. */
static volatile bool measurementComplete;

/**************************************************************************//**
 * @brief This vector stores the latest read values from the ACMP
 * @param ACMP_CHANNELS Vector of channels.
 *****************************************************************************/
static volatile uint32_t channelValues[ACMP_CHANNELS] = { 0 };

/**************************************************************************//**
 * @brief  This stores the maximum values seen by a channel
 * @param ACMP_CHANNELS Vector of channels.
 *****************************************************************************/
static volatile uint32_t channelMaxValues[ACMP_CHANNELS] = { 0 };


static const ACMP_Channel_TypeDef channelList[ACMP_CHANNELS] = CAPSENSE_CHANNELS;




/**************************************************************************//**
 * @brief
 *   Initializes the capacitive sense system.
 *
 * @details
 *   Capacitive sensing uses two timers: TIMER0 and TIMER1 as well as ACMP.
 *   ACMP is set up in cap-sense (oscillator mode).
 *   TIMER1 counts the number of pulses generated by ACMP_CAPSENSE.
 *   When TIMER0 expires it generates an interrupt.
 *   The number of pulses counted by TIMER1 is then stored in channelValues
 *****************************************************************************/
void CAPSENSE_Init(void)
{
  /* Use the default STK capacative sensing setup */
  ACMP_CapsenseInit_TypeDef capsenseInit = ACMP_CAPSENSE_INIT_DEFAULT;

  /* Enable TIMER0, TIMER1, ACMP_CAPSENSE and PRS clock */
  CMU_ClockEnable(cmuClock_HFPER, true);
  CMU_ClockEnable(cmuClock_TIMER0, true);
  CMU_ClockEnable(cmuClock_TIMER1, true);
#if defined(ACMP_CAPSENSE_CMUCLOCK)
  CMU_ClockEnable(ACMP_CAPSENSE_CMUCLOCK, true);
#else
  CMU->HFPERCLKEN0 |= ACMP_CAPSENSE_CLKEN;
#endif
  CMU_ClockEnable(cmuClock_PRS, true);

  /* Initialize TIMER0 - Prescaler 2^9, top value 10, interrupt on overflow */
  TIMER0->CTRL = TIMER_CTRL_PRESC_DIV512;
  TIMER0->TOP  = 10;		// was 10 og
  TIMER0->IEN  = TIMER_IEN_OF;
  TIMER0->CNT  = 0;

  /* Initialize TIMER1 - Prescaler 2^10, clock source CC1, top value 0xFFFF */
  TIMER1->CTRL = TIMER_CTRL_PRESC_DIV1024 | TIMER_CTRL_CLKSEL_CC1;
  TIMER1->TOP  = 0xFFFF;

  /*Set up TIMER1 CC1 to trigger on PRS channel 0 */
  TIMER1->CC[1].CTRL = TIMER_CC_CTRL_MODE_INPUTCAPTURE /* Input capture      */
					   | TIMER_CC_CTRL_PRSSEL_PRSCH0   /* PRS channel 0      */
					   | TIMER_CC_CTRL_INSEL_PRS       /* PRS input selected */
					   | TIMER_CC_CTRL_ICEVCTRL_RISING /* PRS on rising edge */
					   | TIMER_CC_CTRL_ICEDGE_BOTH;    /* PRS on rising edge */

  /*Set up PRS channel 0 to trigger on ACMP1 output*/
  PRS->CH[0].CTRL = PRS_CH_CTRL_EDSEL_POSEDGE      /* Posedge triggers action */
					| PRS_CH_CTRL_SOURCESEL_ACMP_CAPSENSE      /* PRS source */
					| PRS_CH_CTRL_SIGSEL_ACMPOUT_CAPSENSE;     /* PRS source */

  /* Set up ACMP1 in capsense mode */
  capsenseInit.enable = false;
  capsenseInit.resistor = acmpResistor7;
  capsenseInit.hysteresisLevel_0 = acmpHysteresisLevel9;
  capsenseInit.hysteresisLevel_1 = acmpHysteresisLevel9;

  capsenseInit.vddLevelHigh = 0x3A;
  capsenseInit.vddLevelLow = 0x25;

  ACMP_CapsenseInit(ACMP_CAPSENSE, &capsenseInit);

  ACMP1->IEN = ACMP_IEN_WARMUP;

  /* Enable TIMER0 interrupt */
  NVIC_EnableIRQ(TIMER0_IRQn);
}

/**************************************************************************//**
 * @brief Get the current normalized channelValue for a channel
 * @param channel The channel.
 * @return The channel value in range (0-256).
 *****************************************************************************/
uint32_t CAPSENSE_getVal(uint8_t channel)
{
  return channelValues[channel];
}



/**************************************************************************//**
 * @brief Get the current normalized channelValue for a channel
 * @param channel The channel.
 * @return The channel value in range (0-256).
 *****************************************************************************/
uint32_t CAPSENSE_getNormalizedVal(uint8_t channel)
{
  uint32_t max = channelMaxValues[channel];
  return (channelValues[channel] << 8) / max;
}

/**************************************************************************//**
 * @brief Get the state of the Gecko Button
 * @param channel The channel.
 * @return true if the button is "pressed"
 *         false otherwise.
 *****************************************************************************/
bool CAPSENSE_getPressed(uint8_t channel)
{
  uint32_t treshold;
  /* Treshold is set to 50% below the maximum value */
  /* This calculation is performed in two steps because channelMaxValues is
   * volatile. */
//  uint32_t ch0_norm = CAPSENSE_getNormalizedVal(0);
//  uint32_t ch1_norm = CAPSENSE_getNormalizedVal(1);


  treshold  = channelMaxValues[channel];
  treshold -= channelMaxValues[channel] >> 1;

  if (channelValues[channel] < treshold) {
    return true;
  }
  return false;
}


/**************************************************************************//**
 * @brief
 *   Start a capsense measurement of a specific channel and waits for
 *   it to complete.
 *****************************************************************************/
void CAPSENSE_Start_Measurement(uint8_t channel)
{
  currentChannel = channel;


  ACMP_Enable(ACMP_CAPSENSE);
  /* Set up this channel in the ACMP. */
  ACMP_CapsenseChannelSet(ACMP_CAPSENSE, channelList[channel]);

  /* Reset timers */
  TIMER0->CNT = 0;
  TIMER1->CNT = 0;

  /* Start timers */
  measurementComplete = false;
  TIMER0->CMD = TIMER_CMD_START;
  TIMER1->CMD = TIMER_CMD_START;

}


//void CAPSENSE_Sense(void)
//{
//  /* Use the default STK capacative sensing setup and enable it */
//  ACMP_Enable(ACMP_CAPSENSE);
//
//#if defined(CAPSENSE_CHANNELS)
//  for (currentChannel = 0; currentChannel < ACMP_CHANNELS; currentChannel++) {
////  currentChannel = currentChannel % ACMP_CHANNELS;
//	  CAPSENSE_Measure_Channel(channelList[currentChannel]);
//  }
//
//#else
//  /* Iterate through all channels and check which channel is in use */
//  for (currentChannel = 0; currentChannel < ACMP_CHANNELS; currentChannel++) {
//    /* If this channel is not in use, skip to the next one */
//    if (!channelsInUse[currentChannel]) {
//      continue;
//    }
//
//    CAPSENSE_Measure((ACMP_Channel_TypeDef) currentChannel);
//  }
//#endif
//
//}



//void Capsense_Routine(uint32_t event){
//
//	CAPSENSE_state = READY;
//
//	switch(CAPSENSE_state){
//	case READY:
//		currentChannel = 0;
//		ACMP_Enable(ACMP_CAPSENSE);
//		break;
//	case MEASURE:
//		ACMP_Enable(ACMP_CAPSENSE);
//	    CAPSENSE_Measure_Channel(channelList[currentChannel]);
//	    currentChannel++;
//	    if(currentChannel == (ACMP_CHANNELS - 1)){
//	    	CAPSENSE_state = COMPLETE;
//	    }
//	    else{
//	    	CAPSENSE_state = MEASURE;
//	    }
//		break;
//
//	case COMPLETE:
//
//		  /* Disable ACMP while not sensing to reduce power consumption */
//		  ACMP_Disable(ACMP_CAPSENSE);
//		  CAPSENSE_state = READY;
//
//		break;
//	}
//
//
//}


/**************************************************************************//**
 * @brief
 *   TIMER0 interrupt handler.
 *
 * @details
 *   When TIMER0 expires the number of pulses on TIMER1 is inserted into
 *   channelValues. If this values is bigger than what is recorded in
 *   channelMaxValues, channelMaxValues is updated.
 *   Finally, the next ACMP channel is selected.
 *****************************************************************************/
void TIMER0_IRQHandler(void)
{
  uint32_t count;

  /* Stop timers */
  TIMER0->CMD = TIMER_CMD_STOP;
  TIMER1->CMD = TIMER_CMD_STOP;

  /* Clear interrupt flag */
  TIMER0->IFC = TIMER_IFC_OF;

  /* Read out value of TIMER1 */
  count = TIMER1->CNT;

  /* Store value in channelValues */
  channelValues[currentChannel] = count;

  /* Update channelMaxValues */
  if (count > channelMaxValues[currentChannel]) {
	  //channelMaxValues[currentChannel] = count;
	  if(count >50) channelMaxValues[currentChannel] = 50;

	  else channelMaxValues[currentChannel] = count;

  }

  //measurementComplete = true;
  gecko_external_signal(CAP_MEASURE_END);


}


void ACMP1_IRQHandler(void){
	uint32_t int_flag = ACMP1->IF & ACMP1->IEN;
	ACMP1->IFC = int_flag;
	gecko_external_signal(CAP_MEASURE_READY);


}
